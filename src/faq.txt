 
1. Необходимы ли какие-либо дополнительные библиотеки или фреймворки для корректной работы калькулятора?
	Ответ: Да, калькулятор использует библиотеку jquery выше версии 3.0
	
|-----------	

2. Есть ли какие-либо рекомендации по организации html-кода калькулятора?
	Ответ: Конечно. Давайте разберёмся с этими по очереди:
		a. Следует обратить внимание на то, чтобы ко всем html-элементам, которые будут участвовать в формировании итоговой стоимости можно было обратиться, используя один селектор (опция componentsSelector).
			Самое простое решение - ввести доп. класс для таких элементов, но оно не является единственно верным, можно использовать любой другой селектор(в т.ч. и с использованием jquery-фильтров); самое важное - селектор должен охватывать все элементы участвующие в формировании итоговой стоимости
			
		b. В html-коде должен быть элемент, который будет отвечать за демонстрацию итоговой стоимости (опция totalElementSelector)
		
		c. Учтите, что стандартного набора атрибутов элементов формы(большинство элементов калькулятора будут именно ими) не всегда достаточно для того содержать какую-либо информацию элемента, при этом хранить его стоимость ИЛИ стоимость должна быть не фиксированной, а зависить от значения элемента формы. Для таких случаев рекомендуется использовать у элементов несколько атрибутов(согласно спецификации HTML5, можно свободно использовать атрибуты типа data-...). Калькулятор поддерживает 2 направления использования атрибутов:
			-> Атрибут стоимости элемента (опция elemValueAttr) (фиксированная стоимость)
			-> Атрибут множителя значения(стоимости) элемента (опция elemValueFactorAttr) (определяет как должна меняться стоимость в зависимости от значения поля)
			Прим.: Используйте одинаковые наборы атрибутов для всех элементов калькулятора, т.е. если Вы указали у одного элемента атрибут фикс. стоимости как data-fixcost, то и у других элементов он должен называться точно также
			
|-----------	

3. Есть ли какие-либо рекомендации относительно стилей применяемых к калькулятору?
	Ответ: Да, всего лишь небольшое пожелание - подумайте о том, как должен выглядеть элемент, демонстрирующий стоимость текущего элемента калькулятора
		Конечно это не является обязательным. В процессе реализации, Вы можете просто не использовать метод showHint, который и отвечает за демонстрацию стоимости элемента
			
|-----------	

4. Как начать работу с калькулятором?
	Ответ:
		a. Создайте объект на основе класса CostDeterminant;
		b. Передайте все необходимые параметры для работы калькулятора (это можно сделать, как в процессе создания объекта класса(в этом случае параметры передаются в виде объекта), так и позднее);
		c. Запустите функционал калькулятора (метод switchOn)
			
|-----------	

5. А можно получить подробную информацию о всех параметрах, которые можно передать в калькулятор?
	Ответ: Конечно. Вот полный перечень, со соответствующими пояснениями:
		a. totalElementSelector - селектор элемента, в котором будет демонстрироваться итоговая стоимость определённая калькулятором
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
			
		b. componentsSelector - селектор, по которому будет определяться является ли элемент калькулятора учавствующим в формировании итоговой стоимости
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
		
		c. currencyName - обозначение валюты, используемой в калькуляторе
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
		
		d. elemValueAttr - название атрибута, в котором определена стоимость элемента калькулятора
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
		
		e. elemValueFactorAttr - название атрибута, в котором определён множитель стоимости для значения элемента калькулятора
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
		
		f. hintElementID - идентификатор элемента, демонстрирующего стоимость текущего элемента калькулятора
			Ожидаемый тип данных значения: строка
			Обязателен для определения: да
		
		g. elementsValueHandlers - функции, отвечающие за получение значения элемента калькулятора стоимости с привязкой к селектору.
			Структура:
				{
					"селектор":функция,
					...
				}
			Обязателен для определения: да (хотя бы одна пара селектор-функция)
			
		h. compsEvents - функции, отвечающие за обработку событий возникающих на элементах калькулятора стоимости с привязкой к селектору.
			Структура:
				{
					"селектор":
						{
							"событие":функция-обработчик,
							...
						},
					...
				}
			Обязателен для определения: да (хотя бы один селектор и пара событие-функция)	
			
		i. totalCostModifiers - функции, отвечающие за корректировку вычисленной итоговой стоимости.
			Структура:
				[
					функция,
					...
				]
			Обязателен для определения: нет
			
		j. eventsCalledImmediatly - события и селекторы элементов для, которых они должны быть вызваны сразу после включения функционала калькулятора.
			Структура:
				[
					{
						"событие":"селектор"
					},
					...
				]
			Обязателен для определения: нет
			
|-----------	

6. Какие ещё функции? Я должен сам(-а) определять функции для калькулятора?
	Ответ: Да, т.к. калькулятор создавался таким образом, чтобы он мог использоваться в различных структурах html-кода и с различным поведением элементов страницы. НО! Это не значит, что Вам придётся описывать вообще все функции калькулятора. Вам необходимо определить только функции для ключевых моментов работы калькулятора
			
|-----------	

7. Что это за ключевые моменты и как должны быть организованы функции?
	Ответ: Всего таких моментов - 3, но первостепенно важных - 2. Давайте разберёмся что это за моменты и как должны быть организованы функции:
		a. ВАЖНЫЙ! Получение стоимости элемента калькулятора. Т.к. элементы калькулятора могут иметь разный тип, то и получать их стоимость тоже потребуется по-разному. Именно для этих целей и используются эти функции
			Организация функций:
				-> Функция должна принимать 3 аргумента:
					1 - указатель на элемент, чью стоимость необходимо получить
					2 - имя атрибута, содержащего стоимость элемента
					3 - имя атрибута, содержащего множитель для значения элементов
				-> Функция должна возвращать массив состоящий из 2-х элементов:
					1 - стоимость элемента
					2 - множитель для значения элементов
				-> Примечания:
					1 - Предпочтительно перед возвращением массива из функции отдать его в метод convertCompValue, который сформирует корректные значения для определения итоговой стоимости
					2 - Если всё-таки Вы решили возвращать массив напрямую, то учтите следующее:
						- Для возврата корректного значения для любой стоимости без множителя следует использовать следующую формулу: [стоимость,1]						
			Имя опции, отвечающей за данный момент: elementsValueHandlers
			
		b. ВАЖНЫЙ! Обработка событий, возникающих у различных элементов калькулятора. Этот момент даёт широкие возможности кастомизации Вашего калькулятора. Что отслеживать и как реагировать на возникновение событий Вы определяете сами.
			Организация функций:
				-> Здесь Вы делаете всё что покажется Вам необходимым
				-> Замечание относительно обработчиков событий:
					Скорее всего при возникновении события Вам потребуется сделать 2 обязательные вещи:
						1 - Подсчитать и вывести итоговую стоимость; для этого можете использовать метод displayTotalCost
						2 - Вывести стоимость текущего элемента калькулятора; для этого можете использовать метод showHint
						
			Имя опции, отвечающей за данный момент: compsEvents
			
		c. Редактирование вычисленной итоговой стоимости. В некоторых случаях может потребоваться скорректировать итоговую стоимость, например, сезонный коэффициент, скидка и т.п.. Как раз для таких случаев и определяются эти функции
			Организация функций:
				-> Функция должна принимать 1 аргумент:
					1 - итоговая стоимость, которую необходимо скорректировать
				-> Функция должна возвращать в виде числа новую итоговую стоимость (изменённую в результате выполнения функции)
			Имя опции, отвечающей за данный момент: totalCostModifiers
			
|-----------	

8. Вы упоминали несколько методов, существующих у объекта класса калькулятора. А есть ли и другие доступные методы для манипулирования калькулятором?
	Ответ: Да, есть. Давайте посмотрим на полный список таких методов и разберёмся для чего их следует использовать:
		1. switchOn() - запуск функционала калькулятора.
			Передаваемые аргументы: нет
			Возвращаемые значения: нет
	
		2. switchOff() - остановка функционала калькулятора.
			Передаваемые аргументы: нет
			Возвращаемые значения: нет
		
		3. restart() - перезапуск функционала калькулятора. Используется в случае внесения изменений в функционал калькулятора после его запуска.
			Передаваемые аргументы: нет
			Возвращаемые значения: нет
		
		4. displayTotalCost() - подсчёт и вывод итоговой стоимости.
			Передаваемые аргументы: нет
			Возвращаемые значения: нет
	
		5. getTotalCost() - ТОЛЬКО для подсчёт итоговой стоимости.
			Передаваемые аргументы: нет
			Возвращаемые значения: итоговая стоимость(число)
		
		6. getComponentValue() - получение значения определённого элемента калькулятора.
			Передаваемые аргументы: нет
			Возвращаемые значения: стоимость текущего элемента
				Тип: массив
				Ожидаемое значение: [стоимость,множитель]
			Примечания:
				- рекомендуется определять целевой элемент самостоятельно(метод setTargetComp(см. ниже))
				- рекомендуется снимать определение целевого элемента(метод unsetTargetComp(см. ниже)) после получения стоимости элемента
		
		7. showHint(element) - демонстрация стоимости определённого элемента калькулятора. Рекомендуется использовать в функциях-обработчиках событий для элементов калькулятора.
			Передаваемые аргументы: element - ссылка на элемент калькулятора стоимость, которого требуется отобразить
			Возвращаемые значения: нет
		
		8. setTargetComp(t) - определение элемента калькулятора как целевого.
			Передаваемые аргументы: t - ссылка на элемент калькулятора, который требуется определить как целевой
			Возвращаемые значения: нет
	
		9. unsetTargetComp() - снятие определения целевого элемента
			Передаваемые аргументы: нет
			Возвращаемые значения: нет
		
		10. convertCompValue(value) - приведение полученной стоимости элемента калькулятора к виду ожидаемому в getComponentValue.
			Передаваемые аргументы: value - стоимость элемента калькулятора
				Тип: массив
				Ожидаемое значение: [стоимость,множитель]
			Возвращаемые значения: приведённая стоимость элемента калькулятора
				Тип: массив
				Ожидаемое значение: [стоимость,множитель]
			Примечание:
				Рекомендуется использовать в функциях получающих значения определённых элементов калькулятора
		
		11. getOpt(name) - получение значения определённой неструктурированной опции.
			Передаваемые аргументы: name - имя опции калькулятора
				Тип: строка
			Возвращаемые значения: 
				- любой примитивный тип данных, кроме булева
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		12. changeOpt(name,value) - изменение значения определённой неструктурированной опции.
			Передаваемые аргументы:
				name - имя опции калькулятора
					Тип: строка
				value - новое значение опции
					Тип: соответствующий требований конкретной опции (но в любом случае - примитивный тип данных)
			Возвращаемые значения: 
				- true - успешное изменение значения опции
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		Прежде чем мы продолжим знакомство с методами калькулятора, мне стоит рассказать об одной системе, которая используется в большинстве методов представленых далее. Итак, некоторые опции представляют из себя структурированный тип данных(массив/объект), при этом он состоит из нескольких уровней. Реализовывать действия, по получению значения из опции, изменению значения в опции и т.п., используя обычные приёмы было бы довольно проблематично для меня; а их применение было бы крайне запутанно для вас. Поэтому для каждого добавленного в структурированные опции значения определяется "путь доступа", т.е. какие ключи необходимо задействовать начиная с 1-го уровня опции, чтобы "добраться" до целевого значения. Но и это ещё не всё, чтобы не замарачиваться с длинными путями и упорядочить их, был создан общий реестр путей, в которых и содержатся все пути. Для доступа к ним были введены указатели реестра путей. Вам достаточно передать в целевой метод указатель реестра, а все остальные действия уже выполнит метод, основываясь на этом указателе.
		
		13. getFromOpt(regPath) - получение конечного значения определённой структурированной опции.
			Передаваемые аргументы: regPath - указатель реестра путей
				Тип: массив
			Возвращаемые значения: 
				- любой примитивный тип данных, кроме булева
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		14. changeWithinOpt(regPath,newValue) - изменение значения в определённой структурированной опции.
			Передаваемые аргументы:
				regPath - указатель реестра путей
					Тип: массив
				value - новое значение опции
					Тип: соответствующий требований конкретной опции (но в любом случае - примитивный тип данных)
			Возвращаемые значения:  
				- true - успешное изменение значения опции
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		15. removeFromOpt(regPath) - удаление конечного значения из структурированной опции.
			Передаваемые аргументы: regPath - указатель реестра путей
				Тип: массив
			Возвращаемые значения:  
				- ничего - успешное изменение значения опции
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		16. addToElementsValueHandlers(selector,handler) - добавление функции, применяемой для получения значения элемента калькулятора.
			Передаваемые аргументы:
				selector - селектор элемента калькулятора для которого добавляется функция получения значения
					Тип: строка
				handler - функция, используемая для получения значения элемента, соответствующего переданному в 1-м аргументе селектору
					Тип: функция
			Возвращаемые значения:  
				- массив - указатель реестра путей
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
	
		17. addToCompsEvents(selector,event,handler) - добавление функции, применяемой в качестве обработчика события для определённого элемента калькулятора.
			Передаваемые аргументы:
				selector - селектор элемента калькулятора для которого добавляется отслеживание события
					Тип: строка
				event - имя события, которое требуется отслеживать у элемента, соответствующего селектору, переданному в 1-м аргументе
					Тип: строка
				handler - функция-обработчик указанного во 2-м аргументе события
					Тип: функция
			Возвращаемые значения:  
				- массив - указатель реестра путей
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
			Примечание:
				Чтобы не было проблем с реализацией обработчиков событий настоятельно рекомендую после успешного внесения изменений с помощью этого метода произвести перезапуск функционала калькулятора (метод restart)
		
		18. addToTotalCostModifiers(handler) - добавлениt функции, применяемой в качестве корректировщика итоговой стоимости вычисленной калькулятором.
			Передаваемые аргументы: handler - функция корректирующая итоговую стоимость
				Тип: функция
			Возвращаемые значения:  
				- массив - указатель реестра путей
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)
		
		19. addToEventsCalledImmediatly(event,selector) - добавление информации о событии, которое должно быть вызвано для элемента сразу же после включения функционала калькулятора (метод switchOn).
			Передаваемые аргументы:
				event - имя события, которое требуется вызвать
					Тип: строка
				selector - селектор элемента для которого требуется вызвать событие, указанное в 1-м аргументе
					Тип: строка
			Возвращаемые значения:  
				- массив - указатель реестра путей
				- false - ошибка при выполнении метода (посмотрите консоль для информации о причинах ошибки)

P.s. если что-то остаётся непонятным, рекомендую посмотреть на пример реализации калькулятора стоимости (usage_example/calculator.funcs.js)